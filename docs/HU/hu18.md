¡Excelente\! Migrar a MySQL es el paso definitivo para que tu aplicación esté lista para un entorno de producción. Gracias a la excelente arquitectura que ya tienes, este cambio es sorprendentemente sencillo y se centra casi por completo en la configuración.

Aquí tienes la guía completa para la **HU-18**, usando tu experiencia previa como referencia.

-----

# **HU-18 – Migración de la Base de Datos a MySQL**

## 1 Análisis de requerimientos

**Objetivo de la HU-18:**
Reemplazar la base de datos de desarrollo (SQLite) por un sistema de gestión de bases de datos robusto y escalable (MySQL), preparando la aplicación para entornos de producción, multiusuario o despliegues web futuros, sin alterar la lógica de negocio existente.

**Criterios de aceptación:**

  * El `pom.xml` debe incluir la dependencia del conector oficial de MySQL (`mysql-connector-j`) y la dependencia de SQLite debe ser eliminada.
  * El archivo `persistence.xml` debe ser reconfigurado para apuntar a una base de datos MySQL local, utilizando el driver, la URL y el dialecto correctos.
  * Al ejecutar la aplicación, esta debe conectarse a un servidor MySQL y crear automáticamente las tablas en el esquema especificado (ej. `biblioteca_db`).
  * Todas las pruebas y funcionalidades CRUD existentes deben operar correctamente sobre la nueva base de datos MySQL.

-----

## 2 Diseño

**Clases involucradas:**

| Archivo/Clase | Responsabilidad |
| :--- | :--- |
| `pom.xml` | **(Modificado)** Gestiona las dependencias del proyecto. Se encarga de descargar el driver de MySQL y eliminar el de SQLite. |
| `persistence.xml` | **(Modificado)** Contiene la "receta" de conexión. Su responsabilidad es indicarle a Hibernate cómo encontrar y comunicarse con el servidor MySQL. |
| (Todo el resto del código) | **(Sin cambios)** Gracias a JPA, ninguna de tus clases de modelo, repositorio, controlador o vista necesita ser modificada. La abstracción de la base de datos es total. |

**Flujo de ejecución (Al iniciar la aplicación):**

```
(Arranque de la App) -> JPA lee el archivo `persistence.xml` (ahora con datos de MySQL).
                    -> Maven provee el driver `mysql-connector-j.jar`.
                    -> Hibernate usa el `MySQLDialect` para generar SQL compatible con MySQL.
                    -> Se establece una conexión de red con el servidor MySQL en `localhost:3306`.
                    -> (Con `ddl-auto=update`) Hibernate crea/actualiza las tablas en el esquema `biblioteca_db`.
                    -> La aplicación funciona normalmente, pero ahora sobre MySQL.
```

-----

## 3 Preparación del Entorno

Antes de cambiar el código, necesitas tener MySQL listo.

1.  **Instala MySQL:** Si no lo tienes, instala MySQL Server en tu máquina. Herramientas como [XAMPP](https://www.apachefriends.org/index.html) o [enlace sospechoso eliminado] son excelentes opciones.
2.  **Crea la Base de Datos:** Usando una herramienta como MySQL Workbench o phpMyAdmin, ejecuta la siguiente sentencia SQL para crear una base de datos vacía.
    ```sql
    CREATE DATABASE biblioteca_db;
    ```
    ¡Eso es todo\! No necesitas crear las tablas manualmente, Hibernate lo hará por ti.

-----

## 4 Codificación

El cambio se realiza en solo dos archivos.

### **4.1 `pom.xml` (Modificado)**

Edita tu `pom.xml` para intercambiar los conectores de base de datos.

```xml
<dependencies>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.4.0</version> </dependency>
</dependencies>
```

### **4.2 `src/main/resources/META-INF/persistence.xml` (Modificado)**

Actualiza las propiedades de conexión. Nota que los nombres de las propiedades cambian de `javax.*` (versión antigua que usaste en tu ejemplo) a `jakarta.*` (versión moderna que usa tu proyecto).

```xml
<properties>
    <property name="jakarta.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
    
    <property name="jakarta.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/biblioteca_db?serverTimezone=UTC"/>
    
    <property name="jakarta.persistence.jdbc.user" value="root"/>
    <property name="jakarta.persistence.jdbc.password" value="password"/>
    
    <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/>
    
    <property name="hibernate.hbm2ddl.auto" value="update"/>
    <property name="hibernate.show_sql" value="true"/>
    <property name="hibernate.format_sql" value="true"/>
</properties>
```

-----

## 5 Compilación y Pruebas

### **5.1 Compilación**

Ejecuta `Clean and Build` en NetBeans. Maven descargará el nuevo conector de MySQL y eliminará el de SQLite.

### **5.2 Pruebas**

**¡No necesitas cambiar ningún archivo de prueba\!** Simplemente, ejecuta toda tu suite de tests de nuevo.

**Ejecutar tests:**

```bash
mvn test
```

Si todos los tests pasan, significa que tu lógica de negocio es independiente de la base de datos y la migración ha sido un éxito. Al ejecutar las pruebas, verás en la consola que Hibernate ahora genera sentencias SQL específicas para MySQL.

-----

**Conclusión:**

  * **HU-18 está completamente implementada**. Has migrado exitosamente la capa de persistencia de SQLite a MySQL.
  * El cambio solo requirió modificar archivos de configuración (`pom.xml` y `persistence.xml`), demostrando la **potencia y flexibilidad de tu arquitectura desacoplada**.
  * Tu aplicación ahora utiliza una base de datos de nivel de producción, lista para futuras mejoras y despliegues más complejos.